<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>AuthenticationPlugin.SessionAuthenticator (matssocket-server-api 0.19.0-2022-11-11 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="declaration: package: io.mats3.matssocket, interface: AuthenticationPlugin, interface: SessionAuthenticator">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">io.mats3.matssocket</a></div>
<h1 title="Interface AuthenticationPlugin.SessionAuthenticator" class="title">Interface AuthenticationPlugin.SessionAuthenticator</h1>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>Enclosing interface:</dt>
<dd><a href="AuthenticationPlugin.html" title="interface in io.mats3.matssocket">AuthenticationPlugin</a></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public static interface </span><span class="element-name type-name-label">AuthenticationPlugin.SessionAuthenticator</span></div>
<div class="block">An instance of this interface shall be returned upon invocation of <a href="AuthenticationPlugin.html#newSessionAuthenticator()"><code>AuthenticationPlugin.newSessionAuthenticator()</code></a>. The
 implementation may choose whether it is a singleton, or if a new instance is returned per invocation (which then
 means there is a unique instance per WebSocket/MatsSocket Session, thus you can hold values for the session
 there).</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button><button id="method-summary-table-tab5" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab5', 3)" class="table-tab">Default Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#authorizeUserForTopic(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)" class="member-name-link">authorizeUserForTopic</a><wbr>(<a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationContext</a>&nbsp;context,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;topicId)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Decide whether the specified Principal/User should be allowed to subscribe to the specified Topic.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#checkHandshake(javax.websocket.server.ServerEndpointConfig,javax.websocket.server.HandshakeRequest,javax.websocket.HandshakeResponse)" class="member-name-link">checkHandshake</a><wbr>(javax.websocket.server.ServerEndpointConfig&nbsp;config,
 javax.websocket.server.HandshakeRequest&nbsp;request,
 javax.websocket.HandshakeResponse&nbsp;response)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Implement this if you want to do a check on any other header values, e.g.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#checkOrigin(java.lang.String)" class="member-name-link">checkOrigin</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;originHeaderValue)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Implement this if you want to do a check on the Origin header value while the initial WebSocket
 Upgrade/Handshake request is still being processed.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationResult</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#initialAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)" class="member-name-link">initialAuthentication</a><wbr>(<a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationContext</a>&nbsp;context,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;authorizationHeader)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Invoked when the MatsSocket initially connects (or reconnects) over WebSocket, and needs to be authenticated
 by the Authorization string supplied via the initial set ("pipeline") of message from the client, typically
 in the HELLO message (which needs to present in the initial pipeline).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#onOpen(javax.websocket.Session,javax.websocket.server.ServerEndpointConfig)" class="member-name-link">onOpen</a><wbr>(javax.websocket.Session&nbsp;webSocketSession,
 javax.websocket.server.ServerEndpointConfig&nbsp;config)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">Invoked straight after the HTTP WebSocket handshake request/response is performed, in the
 <code>Endpoint.onOpen(Session, EndpointConfig)</code> invocation from the WebSocket <code>ServerContainer</code>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationResult</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#reevaluateAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal)" class="member-name-link">reevaluateAuthentication</a><wbr>(<a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationContext</a>&nbsp;context,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;authorizationHeader,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Principal.html" title="class or interface in java.security" class="external-link">Principal</a>&nbsp;existingPrincipal)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Invoked on every subsequent "pipeline" of incoming messages (including every time the Client supplies a new
 Authorization string).</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code>default <a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationResult</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5"><code><a href="#reevaluateAuthenticationForOutgoingMessage(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal,long)" class="member-name-link">reevaluateAuthenticationForOutgoingMessage</a><wbr>(<a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationContext</a>&nbsp;context,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;authorizationHeader,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Principal.html" title="class or interface in java.security" class="external-link">Principal</a>&nbsp;existingPrincipal,
 long&nbsp;lastAuthenticatedTimestamp)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab5">
<div class="block">This method is invoked each time the server wants to send a message to the client - either a REPLY to a
 request from the Client, or a Server-to-Client <a href="MatsSocketServer.html#send(java.lang.String,java.lang.String,java.lang.String,java.lang.Object)"><code>SEND</code></a> or <a href="MatsSocketServer.html#request(java.lang.String,java.lang.String,java.lang.String,java.lang.Object,java.lang.String,java.lang.String,byte%5B%5D)"><code>MatsSocketServer.request(String, String, String, Object, String, String, byte[])</code></a> REQUEST}.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="checkOrigin(java.lang.String)">
<h3>checkOrigin</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">checkOrigin</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;originHeaderValue)</span></div>
<div class="block">Implement this if you want to do a check on the Origin header value while the initial WebSocket
 Upgrade/Handshake request is still being processed. This invocation is directly forwarded from
 <code>ServerEndpointConfig.Configurator.checkOrigin(String)</code>. Note that you do not have anything else to go by here, it is a
 static check. If you want to evaluate other headers (or probably more relevant for web clients, parameters),
 to decide upon allowed Origins, you can get the Origin header from the <code>HandshakeRequest</code> within the
 <a href="#checkHandshake(javax.websocket.server.ServerEndpointConfig,javax.websocket.server.HandshakeRequest,javax.websocket.HandshakeResponse)"><code>checkHandshake(ServerEndpointConfig, HandshakeRequest, HandshakeResponse)</code></a> checkHandshake(..)} - that
 is however one step later in the establishing of the socket (response is already sent, so if you decide
 against the session there, the socket will be opened, then immediately closed).
 <p/>
 <b>The default implementation returns <code>true</code>, i.e. letting all connections through this step.</b></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>originHeaderValue</code> - which Origin the client connects from - this is mandatory for web browsers to set.</dd>
<dt>Returns:</dt>
<dd>whether this Origin shall be allowed to connect. Default implementation returns <code>true</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="checkHandshake(javax.websocket.server.ServerEndpointConfig,javax.websocket.server.HandshakeRequest,javax.websocket.HandshakeResponse)">
<h3>checkHandshake</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">checkHandshake</span><wbr><span class="parameters">(javax.websocket.server.ServerEndpointConfig&nbsp;config,
 javax.websocket.server.HandshakeRequest&nbsp;request,
 javax.websocket.HandshakeResponse&nbsp;response)</span></div>
<div class="block">Implement this if you want to do a check on any other header values, e.g. Authorization or Cookies, while the
 initial WebSocket Upgrade/Handshake request is still being processed - before the response is sent. This
 invocation is directly forwarded from
 <code>ServerEndpointConfig.Configurator.modifyHandshake(ServerEndpointConfig, HandshakeRequest, HandshakeResponse)</code>. You may add
 headers to the response object. If this method returns <code>false</code> or throws anything, the WebSocket
 request will immediately be terminated.
 <p/>
 <b>NOTE!</b> We would ideally want to evaluate upon the initial HTTP WebSocket handshake request whether we
 want to talk with this client. The best solution would be an
 <a href="https://tools.ietf.org/html/rfc6750#section-2.1">Authorization header</a> on this initial HTTP
 request. However, since it is not possible to add headers via the WebSocket API in web browsers, this does
 not work. Secondly, we could have added it as a URI parameter, but this is
 <a href="https://tools.ietf.org/html/rfc6750#section-2.3">strongly discouraged</a>. We can use cookies to
 achieve somewhat of the same effect (setting it via <code>document.cookie</code> before running
 <code>new WebSocket(..)</code>), but since it is possible that you'd want to connect to a different domain
 for the WebSocket than the web page was served from, this is is not ideal as a general solution. A trick is
 implemented in MatsSocket, whereby it can do a XmlHttpRequest to a HTTP service that is running on the same
 domain as the WebSocket, which can move the Authorization header to a Cookie, which will be sent along with
 the WebSocket Handshake request - and can thus be checked here.
 <p/>
 <b>The default implementation returns <code>true</code>, i.e. letting all connections through this step.</b></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>config</code> - the <code>ServerEndpointConfig</code> instance.</dd>
<dd><code>request</code> - the HTTP Handshake Request</dd>
<dd><code>response</code> - the HTTP Handshake Response, upon which it is possible to set headers.</dd>
<dt>Returns:</dt>
<dd><code>true</code> if the connection should be let through, <code>false</code> if not.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="onOpen(javax.websocket.Session,javax.websocket.server.ServerEndpointConfig)">
<h3>onOpen</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">onOpen</span><wbr><span class="parameters">(javax.websocket.Session&nbsp;webSocketSession,
 javax.websocket.server.ServerEndpointConfig&nbsp;config)</span></div>
<div class="block">Invoked straight after the HTTP WebSocket handshake request/response is performed, in the
 <code>Endpoint.onOpen(Session, EndpointConfig)</code> invocation from the WebSocket <code>ServerContainer</code>. If
 this method returns <code>false</code> or throws anything, the WebSocket request will immediately be
 terminated by invocation of <code>Session.close()</code> - the implementation of this method may also itself do
 such a close. If you do anything crazy with the Session object which will interfere with the MatsSocket
 messages, that's on you. One thing that could be of interest, is to <code>increase the max idle timeout</code> - which will have effect wrt. to the initial authentication message that is
 expected, as the timeout setting before authenticated session is set to a quite small value by default: 2.5
 seconds (after auth, the timeout is increased). This short timeout is meant to make it slightly more
 difficult to perform DoS attacks by opening many connections and then not send the initial auth-containing
 message. The same goes for <code>max text message buffer size</code>, as
 that is also set low until authenticated: 20KiB.
 <p/>
 <b>The default implementation returns <code>true</code>, i.e. letting all connections through this step.</b></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>webSocketSession</code> - the WebSocket API <code>Session</code> instance.</dd>
<dd><code>config</code> - the <code>ServerEndpointConfig</code> instance.</dd>
<dt>Returns:</dt>
<dd><code>true</code> if the connection should be let through, <code>false</code> if not.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="initialAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)">
<h3>initialAuthentication</h3>
<div class="member-signature"><span class="return-type"><a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationResult</a></span>&nbsp;<span class="element-name">initialAuthentication</span><wbr><span class="parameters">(<a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationContext</a>&nbsp;context,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;authorizationHeader)</span></div>
<div class="block">Invoked when the MatsSocket initially connects (or reconnects) over WebSocket, and needs to be authenticated
 by the Authorization string supplied via the initial set ("pipeline") of message from the client, typically
 in the HELLO message (which needs to present in the initial pipeline). At this point, there is obviously do
 not a Principal yet, so this <a href="AuthenticationPlugin.SessionAuthenticator.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.SessionAuthenticator</code></a> needs to supply it.
 <p/>
 <b>For every next incoming pipeline of messages</b>, the method
 <a href="#reevaluateAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal)"><code>reevaluateAuthentication(...)</code></a> is
 invoked - which, depending on authentication scheme in use, might just always reply
 <a href="AuthenticationPlugin.AuthenticationContext.html#stillValid()"><code>"stillValid"</code></a>, thus trusting the initial authentication - or for
 e.g. OAuth schemes where the token has an expiry time, actually evaluate this expiry time. If that method
 decides that the current Authorization value isn't good enough, the Client will be asked to provide a new one
 (refresh the token).
 <p/>
 <b>For outgoing messages from the Server</b> (that is, Replies to Client-to-Server Requests, and
 Server-to-Client Sends and Requests), the method
 <a href="#reevaluateAuthenticationForOutgoingMessage(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal,long)"><code>reevaluateAuthenticationForOutgoingMessage(AuthenticationContext, String, Principal, long)</code></a> is
 invoked. Again, it depends on the authentication scheme in use: Either trust the initial authentication, or
 re-evaluate whether the current token which the Server has is valid enough. And again, if that method decides
 that the current Authorization value isn't good enough, the Client will be asked to provide a new one
 (refresh the token).
 <p/>
 Note: If this method returns <a href="AuthenticationPlugin.AuthenticationContext.html#invalidAuthentication(java.lang.String)"><code>AuthenticationPlugin.AuthenticationContext.invalidAuthentication(String)</code></a>, the connection is
 immediately closed with <a href="MatsSocketServer.MatsSocketCloseCodes.html#VIOLATED_POLICY"><code>MatsSocketServer.MatsSocketCloseCodes.VIOLATED_POLICY</code></a>.
 <p/>
 <b>NOTE!</b> Read the JavaDoc for
 <a href="#checkHandshake(javax.websocket.server.ServerEndpointConfig,javax.websocket.server.HandshakeRequest,javax.websocket.HandshakeResponse)"><code>checkHandshake(..)</code></a> wrt.
 evaluating the actual HTTP Handshake Request, as you might want to do auth already there.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>context</code> - were you may get additional information (the <code>HandshakeRequest</code> and the WebSocket
            <code>Session</code>), and can create <a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationResult</code></a> to return.</dd>
<dd><code>authorizationHeader</code> - the string value to evaluate for being a valid authorization, in any way you fanzy - it is
            supplied by the client, where you also will have to supply a authentication plugin that creates
            the strings that you here will evaluate.</dd>
<dt>Returns:</dt>
<dd>an <a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationResult</code></a>, which you get from any of the method on the
         <a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationContext</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reevaluateAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal)">
<h3>reevaluateAuthentication</h3>
<div class="member-signature"><span class="return-type"><a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationResult</a></span>&nbsp;<span class="element-name">reevaluateAuthentication</span><wbr><span class="parameters">(<a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationContext</a>&nbsp;context,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;authorizationHeader,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Principal.html" title="class or interface in java.security" class="external-link">Principal</a>&nbsp;existingPrincipal)</span></div>
<div class="block">Invoked on every subsequent "pipeline" of incoming messages (including every time the Client supplies a new
 Authorization string). The reason for separating this out in a different method is that you should want to
 optimize it heavily (read 'Note' below): If the 'existingPrincipal' is still valid (and with that also the
 userId that was supplied at <a href="AuthenticationPlugin.AuthenticationContext.html#authenticated(java.security.Principal,java.lang.String)"><code>AuthenticationPlugin.AuthenticationContext.authenticated(Principal, String)</code></a>), then you can
 return the result of <a href="AuthenticationPlugin.AuthenticationContext.html#stillValid()"><code>AuthenticationPlugin.AuthenticationContext.stillValid()</code></a>. A correct, albeit possibly slow,
 implementation of this method is to just forward the call to
 <a href="#initialAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)"><code>initialAuthentication(..)</code></a> - it was however
 decided to not default-implement this solution in the interface, so that you should consider the implications
 of this.
 <p/>
 If the method returns <a href="AuthenticationPlugin.AuthenticationContext.html#invalidAuthentication(java.lang.String)"><code>invalidAuthentication()</code></a>,
 the server will not process the incoming pipeline, and instead ask the client for re-auth, and when this
 comes in and is valid, the processing will ensue (it holds the already provided messages so that client does
 not need to deliver them again). <b>Notice: As opposed to the
 <a href="#initialAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)"><code>initialAuthentication</code></a>, replying
 invalidAuthentication() does NOT immediately close the WebSocket</b>, but only implies that the client needs
 to supply a new authorization headers before processing will go on.
 <p/>
 <b>NOTE!</b> You might want to hold on to the 'authorizationHeader' between the invocations to quickly
 evaluate whether it has changed: In e.g. an OAuth setting, where the authorizationHeader is a bearer access
 token, you could shortcut evaluation: If it has not changed, then you might be able to just evaluate whether
 it has expired by comparing a timestamp that you stored when first evaluating it, towards the current time.
 However, if the authorizationHeader (token) has changed, you would do full evaluation of it, as with
 <a href="#initialAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)"><code>initialAuthentication(..)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>context</code> - were you may get additional information (the <code>HandshakeRequest</code> and the WebSocket
            <code>Session</code>), and can create <a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationResult</code></a> to return.</dd>
<dd><code>authorizationHeader</code> - the string value to evaluate for being a valid authorization, in any way you fanzy - it is
            supplied by the client, where you also will have to supply a authentication plugin that creates
            the strings that you here will evaluate.</dd>
<dd><code>existingPrincipal</code> - The <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Principal.html" title="class or interface in java.security" class="external-link"><code>Principal</code></a> that was returned with the last authentication (either initial or
            reevaluate).</dd>
<dt>Returns:</dt>
<dd>an <a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationResult</code></a>, which you get from any of the method on the
         <a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationContext</code></a>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reevaluateAuthenticationForOutgoingMessage(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal,long)">
<h3>reevaluateAuthenticationForOutgoingMessage</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type"><a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationResult</a></span>&nbsp;<span class="element-name">reevaluateAuthenticationForOutgoingMessage</span><wbr><span class="parameters">(<a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationContext</a>&nbsp;context,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;authorizationHeader,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Principal.html" title="class or interface in java.security" class="external-link">Principal</a>&nbsp;existingPrincipal,
 long&nbsp;lastAuthenticatedTimestamp)</span></div>
<div class="block">This method is invoked each time the server wants to send a message to the client - either a REPLY to a
 request from the Client, or a Server-to-Client <a href="MatsSocketServer.html#send(java.lang.String,java.lang.String,java.lang.String,java.lang.Object)"><code>SEND</code></a> or <a href="MatsSocketServer.html#request(java.lang.String,java.lang.String,java.lang.String,java.lang.Object,java.lang.String,java.lang.String,byte%5B%5D)"><code>MatsSocketServer.request(String, String, String, Object, String, String, byte[])</code></a> REQUEST}.
 <p/>
 If the method returns <a href="AuthenticationPlugin.AuthenticationContext.html#invalidAuthentication(java.lang.String)"><code>invalidAuthentication()</code></a>,
 the server will now hold this delivery, and instead ask the client for re-auth, and when this comes in and is
 valid, the delivery will ensue. <b>Notice: As opposed to the
 <a href="#initialAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)"><code>initialAuthentication</code></a>, replying
 invalidAuthentication() does NOT immediately close the WebSocket</b>, but only implies that the client needs
 to supply a new authorization headers before getting the outbound messages.
 <p/>
 It is default-implemented to invoke
 <a href="#reevaluateAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal)"><code>reevaluateAuthentication(..)</code></a>, but
 the reason for separating this out in (yet a) different method is that you might want to add a bit more slack
 wrt. expiry if OAuth-style auth is in play: Let's say a request from the Client is performed right at the
 limit of the expiry of the token (where the "slack" is set to a ridiculously low 10 seconds). But let's now
 imagine that this request takes 11 seconds to complete. If you do not override the default implementation,
 the default implementation will forward to <code>reevaluateAuthentication</code>, get
 <a href="AuthenticationPlugin.AuthenticationContext.html#invalidAuthentication(java.lang.String)"><code>invalidAuthentication()</code></a> as answer, and thus
 initiate a full round-trip to the client and to the auth-server to get a new token. However, considering that
 this <a href="AuthenticationPlugin.SessionAuthenticator.html" title="interface in io.mats3.matssocket"><code>SessionAuthenticator</code></a> was OK with the authentication when the request came
 it, and that by the situation's definition the WebSocket connection has not gone done in the mean time
 (otherwise it would have had to do full initial auth), one could argue that a Reply should have some extra
 room wrt. expiry. For Server-to-Client messages SEND and REQUEST, the same mechanism is employed, and I'd
 argue that the same arguments hold: This <code>SessionAuthenticator</code> was happy with the authentication some
 few minutes ago and the connection has not broken in the meantime, so you should work pretty hard to set up a
 situation where a REQUEST from the Server or some data using SEND from the Server would be a large security
 consideration.
 <p/>
 You get provided the last time this <code>SessionAuthenticator</code> was happy with this exact Authorization
 value as parameter 'lastAuthenticatedTimestamp' - that is, this timestamp is reset each time
 <a href="#initialAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)"><code>initialAuthentication(..)</code></a> and
 <a href="#reevaluateAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal)"><code>reevaluateAuthentication</code></a> answers
 any of <a href="AuthenticationPlugin.AuthenticationContext.html#authenticated(java.security.Principal,java.lang.String)"><code>authenticated</code></a> or
 <a href="AuthenticationPlugin.AuthenticationContext.html#stillValid()"><code>AuthenticationPlugin.AuthenticationContext.stillValid()</code></a>.
 <p/>
 An ok implementation is therefore to simply answer <a href="AuthenticationPlugin.AuthenticationContext.html#stillValid()"><code>stillValid()</code></a> if
 the 'lastAuthenticatedTimestamp' parameter is less than X minutes ago, otherwise answer
 <a href="AuthenticationPlugin.AuthenticationContext.html#invalidAuthentication(java.lang.String)"><code>invalidAuthentication()</code></a> (and thus the client will
 be asked to supply new auth). Another slightly more elaborate implementation is to store the token and the
 actual expiry time of the token in <a href="#reevaluateAuthentication(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String,java.security.Principal)"><code>reevaluateAuthentication(..)</code></a>, and if the token is the same with this invocation, just evaluate the expiry
 time against current time, but add X minutes slack to this evaluation.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>context</code> - were you may get additional information (the <code>HandshakeRequest</code> and the WebSocket
            <code>Session</code>), and can create <a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationResult</code></a> to return.</dd>
<dd><code>authorizationHeader</code> - the string value to evaluate for being a valid authorization, in any way you fanzy - it is
            supplied by the client, where you also will have to supply a authentication plugin that creates
            the strings that you here will evaluate.</dd>
<dd><code>existingPrincipal</code> - The <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Principal.html" title="class or interface in java.security" class="external-link"><code>Principal</code></a> that was returned with the last authentication (either initial or
            reevaluate).</dd>
<dd><code>lastAuthenticatedTimestamp</code> - the millis-since-epoch of when this exact 'authorizationHeader' was deemed OK by this same
            <code>SessionAuthenticator</code>.</dd>
<dt>Returns:</dt>
<dd>an <a href="AuthenticationPlugin.AuthenticationResult.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationResult</code></a>, which you get from any of the method on the
         <a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationContext</code></a> - preferably either <a href="AuthenticationPlugin.AuthenticationContext.html#stillValid()"><code>stillValid()</code></a> or <a href="AuthenticationPlugin.AuthenticationContext.html#invalidAuthentication(java.lang.String)"><code>invalidAuthentication()</code></a>
         based on whether to let this Server-to-Client message through, or force the Client to reauthenticate
         before getting the message.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="authorizeUserForTopic(io.mats3.matssocket.AuthenticationPlugin.AuthenticationContext,java.lang.String)">
<h3>authorizeUserForTopic</h3>
<div class="member-signature"><span class="modifiers">default</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">authorizeUserForTopic</span><wbr><span class="parameters">(<a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket">AuthenticationPlugin.AuthenticationContext</a>&nbsp;context,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;topicId)</span></div>
<div class="block">Decide whether the specified Principal/User should be allowed to subscribe to the specified Topic.
 <p/>
 Note: The 'authorizationHeader' is already validated by one of the <i>authentication</i> methods, which have
 supplied the Principal and userId present in the supplied <a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationContext</code></a>.
 <p/>
 <b>The default implementation return <code>true</code>, i.e. letting all users subscribe to all Topics.</b></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>context</code> - the <a href="AuthenticationPlugin.AuthenticationContext.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin.AuthenticationContext</code></a> for reference - this has getters for the info you should require
            to decide whether the current Client user should be allowed to subscribe to the given topic.</dd>
<dd><code>topicId</code> - the Id of the Topic the client tries to subscribe to</dd>
<dt>Returns:</dt>
<dd><code>true</code> if the user should be allowed to subscribe to the Topic, <code>false</code> if the
         user should not be allowed to subscribe - he will then not get any messages sent over the Topic.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
