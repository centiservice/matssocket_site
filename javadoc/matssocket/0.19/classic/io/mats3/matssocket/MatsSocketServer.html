<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>MatsSocketServer (matssocket 0.19.0-2022-11-11 API)</title>
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MatsSocketServer (matssocket 0.19.0-2022-11-11 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":18,"i10":6,"i11":18,"i12":18,"i13":6,"i14":6,"i15":6,"i16":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../io/mats3/matssocket/ClusterStoreAndForward.WrongUserException.html" title="class in io.mats3.matssocket"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/mats3/matssocket/MatsSocketServer.html" target="_top">Frames</a></li>
<li><a href="MatsSocketServer.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.mats3.matssocket</div>
<h2 title="Interface MatsSocketServer" class="title">Interface MatsSocketServer</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><a href="../../../io/mats3/matssocket/impl/DefaultMatsSocketServer.html" title="class in io.mats3.matssocket.impl">DefaultMatsSocketServer</a></dd>
</dl>
<hr>
<br>
<pre>public interface <span class="typeNameLabel">MatsSocketServer</span></pre>
<div class="block">The MatsSocket Java library, along with its several clients libraries, is a WebSocket-"extension" of the Mats library
 <i>(there are currently clients for JavaScript (web and Node.js) and Dart (Dart and Flutter))</i>. It provides for
 asynchronous communications between a Client and a MatsSocketServer using WebSockets, which again asynchronously
 interfaces with the Mats API. The result is a simple programming model on the client, providing Mats's asynchronous
 and guaranteed delivery aspects all the way from the client, to the server, and back, and indeed the other way
 ("push", including requests from Server to Client). It is a clearly demarcated solution in that it only utilizes the
 API of the Mats library and the API of the <i>JSR 356 WebSocket API for Java</i> (with some optional hooks that
 typically will be implemented using the Servlet API, but any HTTP server implementation can be employed).
 MatsSocketEndpoints are simple to define, code and reason about, simple to authenticate and authorize, and the
 interface with Mats is very simple, yet flexible.
 <p/>
 Features:
 <ul>
 <li>Very lightweight transport protocol, which is human readable and understandable, with little overhead
 (<a href="../../../io/mats3/matssocket/MatsSocketServer.MessageType.html" title="enum in io.mats3.matssocket"><code>all message types</code></a> and <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketCloseCodes.html" title="enum in io.mats3.matssocket"><code>all socket closure modes</code></a>).</li>
 <li>A TraceId is created on the Client, sent with the client call, through the MatsSocketServer, all the way through
 all Mats stages, back to the Reply - logged along all the steps.</li>
 <li>Provides "Send" and "Request" features both Client-to-Server and Server-to-Client.</li>
 <li>Reconnection in face of broken connections is handled by the Client library, with full feedback solution to the
 end user via event listeners</li>
 <li>Guaranteed delivery both ways, also in face of reconnects at any point, employing an "outbox" and "inbox" on both
 sides, with a three-way handshake protocol for each "information bearing message": Message, acknowledge of message,
 acknowledge of acknowledge.</li>
 <li>Client side Event Listener for ConnectionEvents (e.g. connecting, waiting, session_established, lost_connection),
 for display to end user.</li>
 <li>Client side Event Listener for SessionClosedEvents, which is when the system does not manage to keep the
 guarantees in face of adverse situation on the server side (typically lost database connection in a bad spot).</li>
 <li>Pipelining of messages, which is automatic (i.e. delay of 2 ms after last message enqueued before the pipeline is
 sent) - but with optional "flush()" command to send a pipeline right away.</li>
 <li>Several debugging features in the protocol (full round-trip TraceId, comprehensive logging, and
 <a href="../../../io/mats3/matssocket/AuthenticationPlugin.DebugOption.html" title="enum in io.mats3.matssocket"><code>DebugOptions</code></a>)</li>
 <li>Built-in and simple statistics gathering on the client.</li>
 <li>Simple and straight-forward, yet comprehensive and mandatory, authentication model employing a
 MatsSocketServer-wide server <a href="../../../io/mats3/matssocket/AuthenticationPlugin.html" title="interface in io.mats3.matssocket"><code>AuthenticationPlugin</code></a> paired with a Client authentication callback, and a
 per-MatsSocketEndpoint, per-message <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket"><code>IncomingAuthorizationAndAdapter</code></a>.</li>
 <li>The WebSocket protocol itself has built-in "per-message" compression.</li>
 </ul>
 <p/>
 Notes:
 <ul>
 <li>There is no way to cancel or otherwise control individual messages: The library's simple "send" and
 Promise-yielding "request" operations (with optional "receivedCallback" for the client) is the only way to talk with
 the library. When those methods returns, the operation is queued, and will be transferred to the other side ASAP.
 This works like magic for short and medium messages, but does not constitute a fantastic solution for large payloads
 over bad networks (as typically <i>can</i> be the case with Web apps and mobile apps).</li>
 <li>MatsSockets does not provide "channel multiplexing", meaning that one message (or pipeline of messages) will have
 to be fully transferred before the next one is. This means that if you decide to send over a 200 MB PDF using the
 MatsSocket instance over a 2G cellular network, any subsequent messages issued in the same direction will experience
 a massive delay - i.e. MatsSocket is susceptible to <i>head of line blocking</i>. This again means that you should
 probably not do such large transfers over MatsSocket: Either you should do such a download or upload using ordinary
 HTTP solutions (which can go concurrent with MatsSocket's WebSocket), or employ a secondary MatsSocket instance for
 such larger message if you just cannot get enough of the MatsSocket API - but you would still get more control over
 e.g. progress and cancellation of the transfer with the HTTP approach.</li>
 </ul>
 <p/>
 <b>WARNING! Please make absolutely certain that you understand that incoming messages to MatsSocketEndpoints
 originate directly from the hostile Internet, and you cannot assume that any values are benign - they might be
 specifically tailored to hack or crash your system. Act and code accordingly! It is imperative that you NEVER rely on
 information from the incoming message to determine which user to act as: It would e.g. be absolutely crazy to rely on
 a parameter in an incoming DTO declaring "userId" when deciding which user to place an order for, or to withdraw
 money from. Such information must be gotten by the authenticated elements, which are
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getPrincipal--"><code>incomingContext.getPrincipal()</code></a> and
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getUserId--"><code>incomingContext.getUserId()</code></a>. The same holds for authorization
 of access: If the incoming DTO from the Client demands to see <i>'top secret folder'</i>, you cannot rely on this,
 even though you filtered which elements the user can request in a <i>'folders you are allowed to access'</i>-list in
 a previous message to the Client. The user handling the Client could just hack the request DTO to request the top
 secret folder even though this was not present in the list of allowed folders. You must therefore again authorize
 that the requesting user actually has access to the folder he requests before returning it.</b> This is obviously
 exactly the same as for any other transport, e.g. HTTP: It is just to point out that MatsSocket doesn't magically
 relieve you from doing proper validation and authorization of incoming message.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Interface and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket">MatsSocketServer.ActiveMatsSocketSession</a></span></code>
<div class="block">Represents an active node-local MatsSocketSession - i.e.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSessionDto.html" title="class in io.mats3.matssocket">MatsSocketServer.ActiveMatsSocketSessionDto</a></span></code>
<div class="block">Implementation of <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ActiveMatsSocketSession</code></a>, which is serializable both for MatsSocket and Mats, i.e.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></span></code>
<div class="block">RuntimeException raised from methods which directly interfaces with the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>ClusterStoreAndForward</code></a> and which
 cannot "hide" the situation if the data store doesn't work.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;<a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="type parameter in MatsSocketServer.IncomingAuthorizationAndAdapter">I</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="type parameter in MatsSocketServer.IncomingAuthorizationAndAdapter">MR</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="type parameter in MatsSocketServer.IncomingAuthorizationAndAdapter">R</a>&gt;</span></code>
<div class="block">Should handle Authorization evaluation on the supplied <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getPrincipal--"><code>Principal</code></a> and decide whether this message should be forwarded to the Mats fabric (or directly resolved, rejected
 or denied).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket">MatsSocketServer.LiveMatsSocketSession</a></span></code>
<div class="block">A <i>live</i> representation of a MatsSocketSession.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketCloseCodes.html" title="enum in io.mats3.matssocket">MatsSocketServer.MatsSocketCloseCodes</a></span></code>
<div class="block">WebSocket CloseCodes used in MatsSocket, and for what.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="type parameter in MatsSocketServer.MatsSocketEndpoint">I</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="type parameter in MatsSocketServer.MatsSocketEndpoint">MR</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="type parameter in MatsSocketServer.MatsSocketEndpoint">R</a>&gt;</span></code>
<div class="block">Representation of a MatsSocketEndpoint.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointContext.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpointContext</a>&lt;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointContext">I</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointContext">MR</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointContext">R</a>&gt;</span></code>
<div class="block">Root for both <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.MatsSocketEndpointIncomingContext</code></a> and <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointReplyContext.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.MatsSocketEndpointReplyContext</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpointIncomingContext</a>&lt;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointIncomingContext">I</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointIncomingContext">MR</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointIncomingContext">R</a>&gt;</span></code>
<div class="block">The context which the <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.IncomingAuthorizationAndAdapter</code></a> gets to work with when handling an incoming
 MatsSocket message.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointReplyContext.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpointReplyContext</a>&lt;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointReplyContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointReplyContext">I</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointReplyContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointReplyContext">MR</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointReplyContext.html" title="type parameter in MatsSocketServer.MatsSocketEndpointReplyContext">R</a>&gt;</span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEnvelopeDto.html" title="class in io.mats3.matssocket">MatsSocketServer.MatsSocketEnvelopeDto</a></span></code>
<div class="block">This is the entire "Wire transport" DTO of MatsSocket.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEnvelopeWithMetaDto.html" title="class in io.mats3.matssocket">MatsSocketServer.MatsSocketEnvelopeWithMetaDto</a></span></code>
<div class="block">Extension of <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEnvelopeDto.html" title="class in io.mats3.matssocket"><code>MatsSocketServer.MatsSocketEnvelopeDto</code></a> which carries some metadata about the processing of the Envelope.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketSession.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketSession</a></span></code>
<div class="block">A MatsSocketSession, either as represented in the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>data store</code></a> when gotten via
 <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getMatsSocketSessions-boolean-java.lang.String-java.lang.String-java.lang.String-"><code>getMatsSocketSessions(boolean, String, String, String)</code></a> (returning <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketSessionDto.html" title="class in io.mats3.matssocket"><code>MatsSocketSessionDto</code></a>), or an <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>ActiveMatsSocketSession</code></a> representing an active
 MatsSocketSession connected to this node of the MatsSocketServer instance when gotten via
 <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getActiveMatsSocketSessions--"><code>getActiveMatsSocketSessions()</code></a> (returning <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSessionDto.html" title="class in io.mats3.matssocket"><code>ActiveMatsSocketSessionDto</code></a>),
 or a <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>LiveMatsSocketSession</code></a> which is an interface view over the actual live session
 in the MatsSocketServer when gotten via <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getLiveMatsSocketSessions--"><code>getLiveMatsSocketSessions()</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketSessionDto.html" title="class in io.mats3.matssocket">MatsSocketServer.MatsSocketSessionDto</a></span></code>
<div class="block">Implementation of <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.MatsSocketSession</code></a>, which is serializable both for MatsSocket and Mats, i.e.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MessageEvent.html" title="interface in io.mats3.matssocket">MatsSocketServer.MessageEvent</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MessageEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.MessageEventListener</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.MessageType.html" title="enum in io.mats3.matssocket">MatsSocketServer.MessageType</a></span></code>
<div class="block">All Message Types (aka MatsSocket Envelope Types) used in the wire-protocol of MatsSocket.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.ReplyAdapter</a>&lt;<a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="type parameter in MatsSocketServer.ReplyAdapter">I</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="type parameter in MatsSocketServer.ReplyAdapter">MR</a>,<a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="type parameter in MatsSocketServer.ReplyAdapter">R</a>&gt;</span></code>
<div class="block">Used to transform the reply message from the Mats endpoint to the reply for the MatsSocket endpoint, and decide
 whether to resolve or reject the waiting Client-side Promise (i.e.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.html" title="interface in io.mats3.matssocket">MatsSocketServer.SessionEstablishedEvent</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.SessionEstablishedEventListener</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.html" title="interface in io.mats3.matssocket">MatsSocketServer.SessionRemovedEvent</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.SessionRemovedEventListener</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t5" class="tableTab"><span><a href="javascript:show(16);">Default Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#addMessageEventListener-io.mats3.matssocket.MatsSocketServer.MessageEventListener-">addMessageEventListener</a></span>(<a href="../../../io/mats3/matssocket/MatsSocketServer.MessageEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.MessageEventListener</a>&nbsp;listener)</code>
<div class="block"><a href="../../../io/mats3/matssocket/MatsSocketServer.MessageEventListener.html" title="interface in io.mats3.matssocket"><code>MessageEventListener</code></a>s will be invoked for every processed incoming and outgoing
 message for any session.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#addSessionEstablishedEventListener-io.mats3.matssocket.MatsSocketServer.SessionEstablishedEventListener-">addSessionEstablishedEventListener</a></span>(<a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.SessionEstablishedEventListener</a>&nbsp;listener)</code>
<div class="block"><a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.html" title="interface in io.mats3.matssocket"><code>SessionEstablishedEvent</code></a> listeners will be invoked when an
 <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>LiveMatsSocketSession</code></a> is established <b>on this node</b> of the
 <a href="../../../io/mats3/matssocket/MatsSocketServer.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer</code></a> instance cluster, i.e.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#addSessionRemovedEventListener-io.mats3.matssocket.MatsSocketServer.SessionRemovedEventListener-">addSessionRemovedEventListener</a></span>(<a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.SessionRemovedEventListener</a>&nbsp;listener)</code>
<div class="block"><a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.SessionRemovedEvent</code></a> listeners will be invoked when an <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.LiveMatsSocketSession</code></a> is removed from this
 node of the <a href="../../../io/mats3/matssocket/MatsSocketServer.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer</code></a> instance cluster - this is both when a MatsSocketSession is
 <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#DEREGISTER"><code>DEREGISTERed</code></a>, in which case the Client can still
 <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.SessionEstablishedEventType.html#RECONNECT"><code>RECONNECT</code></a> to the same MatsSocketSessionId, and when a
 MatsSocketSession is <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#CLOSE"><code>CLOSEd</code></a> or <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#TIMEOUT"><code>TIMEOUTed</code></a>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#closeSession-java.lang.String-java.lang.String-">closeSession</a></span>(java.lang.String&nbsp;sessionId,
            java.lang.String&nbsp;reason)</code>
<div class="block">Closes the specified MatsSocketSession - can be used to forcibly close an active MatsSocketSession (i.e.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>java.util.SortedMap&lt;java.lang.String,<a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSessionDto.html" title="class in io.mats3.matssocket">MatsSocketServer.ActiveMatsSocketSessionDto</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#getActiveMatsSocketSessions--">getActiveMatsSocketSessions</a></span>()</code>
<div class="block">This returns static, frozen-in-time, "copied-out" DTO-variants of the <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getLiveMatsSocketSessions--"><code>LiveMatsSocketSessions</code></a>.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,<a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket">MatsSocketServer.LiveMatsSocketSession</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#getLiveMatsSocketSessions--">getLiveMatsSocketSessions</a></span>()</code>
<div class="block">Imagine that the MatsSocketServer uses a <code>ConcurrentMap</code> to keep its set of local, live, currently
 connected MatsSocketSessions.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>java.util.SortedMap&lt;java.lang.String,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;?,?,?&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#getMatsSocketEndpoints--">getMatsSocketEndpoints</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketSessionDto.html" title="class in io.mats3.matssocket">MatsSocketServer.MatsSocketSessionDto</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#getMatsSocketSessions-boolean-java.lang.String-java.lang.String-java.lang.String-">getMatsSocketSessions</a></span>(boolean&nbsp;onlyActive,
                     java.lang.String&nbsp;userId,
                     java.lang.String&nbsp;appName,
                     java.lang.String&nbsp;appVersionAtOrAbove)</code>
<div class="block">Unless restricted by the "constraint parameters", this method returns <i>all</i> MatsSocketSessions on this
 MatsSocketServer instance, regardless of whether the session currently is connected, and if connected, which node
 it is connected to.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#getMatsSocketSessionsCount-boolean-java.lang.String-java.lang.String-java.lang.String-">getMatsSocketSessionsCount</a></span>(boolean&nbsp;onlyActive,
                          java.lang.String&nbsp;userId,
                          java.lang.String&nbsp;appName,
                          java.lang.String&nbsp;appVersionAtOrAbove)</code>
<div class="block">Like <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getMatsSocketSessions-boolean-java.lang.String-java.lang.String-java.lang.String-"><code>getMatsSocketSessions(boolean, String, String, String)</code></a>, only returning the count - this might be
 interesting if there are very many sessions, and you do not need the full DTOs of every Session, just the count
 for a metric to graph or similar.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>default &lt;I,R&gt;&nbsp;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;I,?,R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#matsSocketDirectReplyEndpoint-java.lang.String-java.lang.Class-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-">matsSocketDirectReplyEndpoint</a></span>(java.lang.String&nbsp;matsSocketEndpointId,
                             java.lang.Class&lt;I&gt;&nbsp;incomingClass,
                             java.lang.Class&lt;R&gt;&nbsp;replyClass,
                             <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;I,java.lang.Void,R&gt;&nbsp;incomingAuthEval)</code>
<div class="block"><i>(Convenience-variant of the base method)</i> Registers a MatsSocket Endpoint meant for situations where you
 intend to reply directly in the <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.IncomingAuthorizationAndAdapter</code></a> without forwarding to Mats.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>&lt;I,MR,R&gt;&nbsp;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;I,MR,R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#matsSocketEndpoint-java.lang.String-java.lang.Class-java.lang.Class-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-io.mats3.matssocket.MatsSocketServer.ReplyAdapter-">matsSocketEndpoint</a></span>(java.lang.String&nbsp;matsSocketEndpointId,
                  java.lang.Class&lt;I&gt;&nbsp;incomingClass,
                  java.lang.Class&lt;MR&gt;&nbsp;matsReplyClass,
                  java.lang.Class&lt;R&gt;&nbsp;replyClass,
                  <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;I,MR,R&gt;&nbsp;incomingAuthEval,
                  <a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.ReplyAdapter</a>&lt;I,MR,R&gt;&nbsp;replyAdapter)</code>
<div class="block">Registers a MatsSocket Endpoint, including a <a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ReplyAdapter</code></a> which can adapt the reply from the Mats
 endpoint before being fed back to the MatsSocket - and also decide whether to resolve or reject the waiting
 Client Promise.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>default &lt;I,R&gt;&nbsp;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;I,R,R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#matsSocketEndpoint-java.lang.String-java.lang.Class-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-">matsSocketEndpoint</a></span>(java.lang.String&nbsp;matsSocketEndpointId,
                  java.lang.Class&lt;I&gt;&nbsp;incomingClass,
                  java.lang.Class&lt;R&gt;&nbsp;replyClass,
                  <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;I,R,R&gt;&nbsp;incomingAuthEval)</code>
<div class="block"><i>(Convenience-variant of the base method)</i> Registers a MatsSocket Endpoint where there is no replyAdapter -
 the reply from the Mats endpoint is directly fed back (as "resolved") to the MatsSocket.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>default &lt;I&gt;&nbsp;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;I,java.lang.Void,java.lang.Void&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#matsSocketTerminator-java.lang.String-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-">matsSocketTerminator</a></span>(java.lang.String&nbsp;matsSocketEndpointId,
                    java.lang.Class&lt;I&gt;&nbsp;incomingClass,
                    <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;I,java.lang.Void,java.lang.Void&gt;&nbsp;incomingAuthEval)</code>
<div class="block"><i>(Convenience-variant of the base method)</i> Registers a MatsSocket Terminator (no reply), specifically for
 Client-to-Server "SEND", and to accept a "REPLY" from a Server-to-Client "REQUEST".</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#publish-java.lang.String-java.lang.String-java.lang.Object-">publish</a></span>(java.lang.String&nbsp;traceId,
       java.lang.String&nbsp;topicId,
       java.lang.Object&nbsp;messageDto)</code>
<div class="block">Publish a Message to the specified Topic, with the specified TraceId.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#request-java.lang.String-java.lang.String-java.lang.String-java.lang.Object-java.lang.String-java.lang.String-byte:A-">request</a></span>(java.lang.String&nbsp;sessionId,
       java.lang.String&nbsp;traceId,
       java.lang.String&nbsp;clientEndpointId,
       java.lang.Object&nbsp;requestDto,
       java.lang.String&nbsp;replyToMatsSocketTerminatorId,
       java.lang.String&nbsp;correlationString,
       byte[]&nbsp;correlationBinary)</code>
<div class="block">Initiates a request to the specified MatsSocketSession, to the specified Client EndpointId, with a replyTo
 specified to (typically) a <a href="../../../io/mats3/matssocket/MatsSocketServer.html#matsSocketTerminator-java.lang.String-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-"><code>MatsSocket terminator</code></a> - which includes a String "correlationString" and byte array "correlationBinary" which can
 be used to correlate the reply to the request (available
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getCorrelationString--"><code>here</code></a> and
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getCorrelationBinary--"><code>here</code></a> for the reply processing).</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#send-java.lang.String-java.lang.String-java.lang.String-java.lang.Object-">send</a></span>(java.lang.String&nbsp;sessionId,
    java.lang.String&nbsp;traceId,
    java.lang.String&nbsp;clientTerminatorId,
    java.lang.Object&nbsp;messageDto)</code>
<div class="block">Sends a message to the specified MatsSocketSession, to the specified Client TerminatorId.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/mats3/matssocket/MatsSocketServer.html#stop-int-">stop</a></span>(int&nbsp;gracefulShutdownMillis)</code>
<div class="block">Closes all <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ActiveMatsSocketSession</code></a> on this node, closing the WebSocket with
 <code>CloseReason.CloseCodes.SERVICE_RESTART</code> (assuming that a MatsSocket service will never truly go down, thus effectively
 asking the client to reconnect, hopefully to another instance).</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="matsSocketEndpoint-java.lang.String-java.lang.Class-java.lang.Class-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-io.mats3.matssocket.MatsSocketServer.ReplyAdapter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matsSocketEndpoint</h4>
<pre>&lt;I,MR,R&gt;&nbsp;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;I,MR,R&gt;&nbsp;matsSocketEndpoint(java.lang.String&nbsp;matsSocketEndpointId,
                                                                        java.lang.Class&lt;I&gt;&nbsp;incomingClass,
                                                                        java.lang.Class&lt;MR&gt;&nbsp;matsReplyClass,
                                                                        java.lang.Class&lt;R&gt;&nbsp;replyClass,
                                                                        <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;I,MR,R&gt;&nbsp;incomingAuthEval,
                                                                        <a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.ReplyAdapter</a>&lt;I,MR,R&gt;&nbsp;replyAdapter)</pre>
<div class="block">Registers a MatsSocket Endpoint, including a <a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ReplyAdapter</code></a> which can adapt the reply from the Mats
 endpoint before being fed back to the MatsSocket - and also decide whether to resolve or reject the waiting
 Client Promise.
 <p/>
 NOTE: If you supply <code>MatsObject</code> as the type 'MR', you will get such an instance, and can decide
 yourself what to deserialize it to - it will be like having a Java method taking Object as argument. However,
 there is no "instanceof" functionality, so you will need to know what type of object it is by other means, e.g.
 by putting some up-flow information on the Mats <code>ProcessContext</code> as a
 <code>TraceProperty</code>.
 <p/>
 NOTE: You need not be specific with the 'R' type being created in the <a href="../../../io/mats3/matssocket/MatsSocketServer.ReplyAdapter.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ReplyAdapter</code></a> - it can be any
 superclass of your intended Reply DTO(s), up to <code>Object</code>. However, the introspection aspects will take a
 hit, i.e. when listing <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getMatsSocketEndpoints--"><code>all MatsSocketEndpoints</code></a> on some monitoring/introspection
 page. This is also a bit like with Java: Methods returning Object as return type are annoying, but can
 potentially be of value in certain convoluted scenarios.</div>
</li>
</ul>
<a name="matsSocketEndpoint-java.lang.String-java.lang.Class-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matsSocketEndpoint</h4>
<pre>default&nbsp;&lt;I,R&gt;&nbsp;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;I,R,R&gt;&nbsp;matsSocketEndpoint(java.lang.String&nbsp;matsSocketEndpointId,
                                                                            java.lang.Class&lt;I&gt;&nbsp;incomingClass,
                                                                            java.lang.Class&lt;R&gt;&nbsp;replyClass,
                                                                            <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;I,R,R&gt;&nbsp;incomingAuthEval)</pre>
<div class="block"><i>(Convenience-variant of the base method)</i> Registers a MatsSocket Endpoint where there is no replyAdapter -
 the reply from the Mats endpoint is directly fed back (as "resolved") to the MatsSocket. The Mats Reply class and
 MatsSocket Reply class is thus the same.
 <p/>
 Types: <code>MR = R</code>
 <p/>
 NOTE: In this case, you cannot specify <code>Object</code> as the 'R' type - this is due to technical limitations with
 how MatsSocket interacts with Mats: You probably have something in mind where a Mats endpoint is configured to
 "return Object", i.e. can return whatever type of DTO it wants, and then feed the output of this directly over as
 the Reply of the MatsSocket endpoint, and over to the Client. However, Mats's and MatsSocket's serialization
 mechanisms are not the same, and can potentially be completely different. Therefore, there needs to be an
 intermediary that deserializes whatever comes out of Mats, and (re-)serializes this to the MatsSocket Endpoint's
 Reply. This can EITHER be accomplished by specifying a specific class, in which case MatsSocket can handle this
 task itself by asking Mats to deserialize to this specified type, and then returning the resulting instance as
 the MatsSocket Endpoint Reply (which then will be serialized using the MatsSocket serialization mechanism). With
 this solution, there is no need for ReplyAdapter, which is the very intent of the present variant of the
 endpoint-creation methods. OTHERWISE, this can be accomplished using user-supplied code, i.e. the ReplyAdapter.
 The MatsSocket endpoint can then forward to one, or one of several, Mats endpoints that return a Reply with one
 of a finite set of types. The ReplyAdapter would then have to choose which type to deserialize the Mats Reply
 into (using the <code>matsObject.toClass(&lt;class&gt;)</code> functionality), and then
 return the desired MatsSocket Reply (which, again, will be serialized using the MatsSocket serialization
 mechanism).</div>
</li>
</ul>
<a name="matsSocketDirectReplyEndpoint-java.lang.String-java.lang.Class-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matsSocketDirectReplyEndpoint</h4>
<pre>default&nbsp;&lt;I,R&gt;&nbsp;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;I,?,R&gt;&nbsp;matsSocketDirectReplyEndpoint(java.lang.String&nbsp;matsSocketEndpointId,
                                                                                       java.lang.Class&lt;I&gt;&nbsp;incomingClass,
                                                                                       java.lang.Class&lt;R&gt;&nbsp;replyClass,
                                                                                       <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;I,java.lang.Void,R&gt;&nbsp;incomingAuthEval)</pre>
<div class="block"><i>(Convenience-variant of the base method)</i> Registers a MatsSocket Endpoint meant for situations where you
 intend to reply directly in the <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.IncomingAuthorizationAndAdapter</code></a> without forwarding to Mats.
 <p/>
 Types: <code>MR = void</code>
 <p/>
 NOTE: In this case, it is possible to specify 'R' = <code>Object</code>. This is because you do not intend to
 interface with Mats at all, so there is no need for MatsSocket Server to know which type any Mats Reply is.</div>
</li>
</ul>
<a name="matsSocketTerminator-java.lang.String-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matsSocketTerminator</h4>
<pre>default&nbsp;&lt;I&gt;&nbsp;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;I,java.lang.Void,java.lang.Void&gt;&nbsp;matsSocketTerminator(java.lang.String&nbsp;matsSocketEndpointId,
                                                                                                      java.lang.Class&lt;I&gt;&nbsp;incomingClass,
                                                                                                      <a href="../../../io/mats3/matssocket/MatsSocketServer.IncomingAuthorizationAndAdapter.html" title="interface in io.mats3.matssocket">MatsSocketServer.IncomingAuthorizationAndAdapter</a>&lt;I,java.lang.Void,java.lang.Void&gt;&nbsp;incomingAuthEval)</pre>
<div class="block"><i>(Convenience-variant of the base method)</i> Registers a MatsSocket Terminator (no reply), specifically for
 Client-to-Server "SEND", and to accept a "REPLY" from a Server-to-Client "REQUEST".
 <p/>
 Types: <code>MR = R = void</code>
 <p/>
 <a href="../../../io/mats3/matssocket/MatsSocketServer.html#request-java.lang.String-java.lang.String-java.lang.String-java.lang.Object-java.lang.String-java.lang.String-byte:A-"><code>request(String, String, String, Object, String, String, byte[])</code></a> request}) operations from the Client.</div>
</li>
</ul>
<a name="send-java.lang.String-java.lang.String-java.lang.String-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>send</h4>
<pre>void&nbsp;send(java.lang.String&nbsp;sessionId,
          java.lang.String&nbsp;traceId,
          java.lang.String&nbsp;clientTerminatorId,
          java.lang.Object&nbsp;messageDto)
   throws <a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></pre>
<div class="block">Sends a message to the specified MatsSocketSession, to the specified Client TerminatorId. This is "fire into the
 void" style messaging, where you have no idea of whether the client received the message. Usage scenarios include
 <i>"New information about order progress"</i> which may or may not include said information (if not included, the
 client must do a request to update) - but where the server does not really care if the client gets the
 information, only that <i>if</i> he actually has the webpage/app open at the time, he will get the message and
 thus update his view of the changed world.
 <p/>
 Note: If the specified session is closed when this method is invoked, the message will (effectively) silently be
 dropped. Even if you just got hold of the sessionId and it was active then, it might asynchronously close while
 you invoke this method.
 <p/>
 Note: The message is put in the outbox, and if the session is actually connected, it will be delivered ASAP,
 otherwise it will rest in the outbox for delivery once the session reconnects. If the session then closes or
 times out while the message is in the outbox, it will be deleted.
 <p/>
 Note: Given that the session actually is live and the client is connected or connects before the session is
 closed or times out, the guaranteed delivery and exactly-once features are in effect, and this still holds in
 face of session reconnects.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></code> - if the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>ClusterStoreAndForward</code></a> makes any problems when putting the outgoing message in the
             outbox.</dd>
</dl>
</li>
</ul>
<a name="request-java.lang.String-java.lang.String-java.lang.String-java.lang.Object-java.lang.String-java.lang.String-byte:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>request</h4>
<pre>void&nbsp;request(java.lang.String&nbsp;sessionId,
             java.lang.String&nbsp;traceId,
             java.lang.String&nbsp;clientEndpointId,
             java.lang.Object&nbsp;requestDto,
             java.lang.String&nbsp;replyToMatsSocketTerminatorId,
             java.lang.String&nbsp;correlationString,
             byte[]&nbsp;correlationBinary)
      throws <a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></pre>
<div class="block">Initiates a request to the specified MatsSocketSession, to the specified Client EndpointId, with a replyTo
 specified to (typically) a <a href="../../../io/mats3/matssocket/MatsSocketServer.html#matsSocketTerminator-java.lang.String-java.lang.Class-io.mats3.matssocket.MatsSocketServer.IncomingAuthorizationAndAdapter-"><code>MatsSocket terminator</code></a> - which includes a String "correlationString" and byte array "correlationBinary" which can
 be used to correlate the reply to the request (available
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getCorrelationString--"><code>here</code></a> and
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getCorrelationBinary--"><code>here</code></a> for the reply processing). Do note that
 since you have no control of when the Client decides to close the browser or terminate the app, you have no
 guarantee that a reply will ever come - so code accordingly.
 <p/>
 Note: the <code>correlationString</code> and <code>correlationBinary</code> are not sent over to the client, but stored
 server side in the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>ClusterStoreAndForward</code></a>. This both means that you do not need to be afraid of size (but
 storing megabytes is silly anyway), but more importantly, this data cannot be tampered with client side - you can
 be safe that what you gave in here is what you get out in the
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getCorrelationString--"><code>context.getCorrelationString()</code></a> and
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getCorrelationBinary--"><code>context.getCorrelationBinary()</code></a>.
 <p/>
 Note: To check whether the client Resolved or Rejected the request, use
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpointIncomingContext.html#getMessageType--"><code>MatsSocketServer.MatsSocketEndpointIncomingContext.getMessageType()</code></a>.
 <p/>
 Note: If the specified session is closed when this method is invoked, the message will (effectively) silently be
 dropped. Even if you just got hold of the sessionId and it was active then, it might asynchronously close while
 you invoke this method.
 <p/>
 Note: The message is put in the outbox, and if the session is actually connected, it will be delivered ASAP,
 otherwise it will rest in the outbox for delivery once the session reconnects. If the session then closes or
 times out while the message is in the outbox, it will be deleted.
 <p/>
 Note: Given that the session actually is live and the client is connected or connects before the session is
 closed or times out, the guaranteed delivery and exactly-once features are in effect, and this still holds in
 face of session reconnects.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></code> - if the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>ClusterStoreAndForward</code></a> makes any problems when putting the outgoing message in the
             outbox.</dd>
</dl>
</li>
</ul>
<a name="publish-java.lang.String-java.lang.String-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publish</h4>
<pre>void&nbsp;publish(java.lang.String&nbsp;traceId,
             java.lang.String&nbsp;topicId,
             java.lang.Object&nbsp;messageDto)
      throws io.mats3.MatsInitiator.MatsBackendRuntimeException</pre>
<div class="block">Publish a Message to the specified Topic, with the specified TraceId. This is pretty much a direct invocation of
 <code>MatsInitiator.MatsInitiate.publish(Object)</code> on the <code>MatsFactory</code>, and thus you might get the
 <code>MatsInitiator.MatsBackendRuntimeException</code> which <code>MatsInitiator.initiateUnchecked(InitiateLambda)</code> raises.
 <p/>
 Note: A published message will be broadcast to all nodes in the MatsSocketServer instance (where each instance
 then evaluates if it have subscribers to the topic and forwards to those). In addition, a certain number of
 messages per topic will be retained in memory to support "replay of lost messages" when a Client looses
 connection and must reconnect. You should consider these facts when designing usage of pub/sub. Messages over
 topics should generally be of interest to more than one party. While it is certainly feasible to have
 user-specific, or even session-specific topics, which could be authorized to only be subscribable by the "owning
 user" or even "owning session" (by use of the
 <code>AuthenticationPlugin</code>), the
 current implementation of pub/sub will result in quite a bit of overhead with extensive use of such an approach.
 Also, even for messages that are of interest to multiple parties, you should consider the size of the messages:
 Maybe not send large PDFs or the entire ISO-images of "newly arrived BlueRays" over a topic - instead send a
 small notification about the fresh BlueRay availability including just essential information and an id, and then
 the client can decide whether he wants to download it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>traceId</code> - traceId for the flow.</dd>
<dd><code>topicId</code> - which Topic to Publish on.</dd>
<dd><code>messageDto</code> - the message to Publish.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>io.mats3.MatsInitiator.MatsBackendRuntimeException</code> - if the Mats implementation cannot connect to the underlying message broker, or are having problems
             interacting with it.</dd>
</dl>
</li>
</ul>
<a name="getMatsSocketEndpoints--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMatsSocketEndpoints</h4>
<pre>java.util.SortedMap&lt;java.lang.String,<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEndpoint.html" title="interface in io.mats3.matssocket">MatsSocketServer.MatsSocketEndpoint</a>&lt;?,?,?&gt;&gt;&nbsp;getMatsSocketEndpoints()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>all registered MatsSocketEndpoints, as a <code>SortedMap[endpointId, endpoint]</code>.</dd>
</dl>
</li>
</ul>
<a name="getMatsSocketSessions-boolean-java.lang.String-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMatsSocketSessions</h4>
<pre>java.util.List&lt;<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketSessionDto.html" title="class in io.mats3.matssocket">MatsSocketServer.MatsSocketSessionDto</a>&gt;&nbsp;getMatsSocketSessions(boolean&nbsp;onlyActive,
                                                                            java.lang.String&nbsp;userId,
                                                                            java.lang.String&nbsp;appName,
                                                                            java.lang.String&nbsp;appVersionAtOrAbove)
                                                                     throws <a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></pre>
<div class="block">Unless restricted by the "constraint parameters", this method returns <i>all</i> MatsSocketSessions on this
 MatsSocketServer instance, regardless of whether the session currently is connected, and if connected, which node
 it is connected to. This is done by reading from the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>data store</code></a>, as opposed to
 methods <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getActiveMatsSocketSessions--"><code>getActiveMatsSocketSessions()</code></a> and <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getLiveMatsSocketSessions--"><code>getLiveMatsSocketSessions()</code></a>, which returns result
 from <i>this node's</i> internal structures - and therefore only returns sessions that are connected <i>right
 now</i>, and are connected to <i>this node</i>. This means that you will get returned both connected sessions,
 and sessions that are not currently connected (unless restricting this via parameter 'onlyActive'). The latter
 implies that they are state=<a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.MatsSocketSessionState.html#DEREGISTERED"><code>MatsSocketServer.ActiveMatsSocketSession.MatsSocketSessionState.DEREGISTERED</code></a>, and the
 <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketSession.html#getNodeName--"><code>MatsSocketServer.MatsSocketSession.getNodeName()</code></a> returns <code>Optional.empty()</code>.
 <p/>
 The parameters are constraints - if a parameter is <code>null</code> or <code>false</code>, that parameter is not
 used in the search criteria, while if it is set, that parameter will constrain the search.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onlyActive</code> - If <code>true</code>, only returns "active" MatsSocketSessions, currently being connected to some
            node, i.e. having <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketSession.html#getNodeName--"><code>MatsSocketServer.MatsSocketSession.getNodeName()</code></a> NOT returning <code>Optional.empty()</code>.</dd>
<dd><code>userId</code> - If non-<code>null</code>, restricts the results to sessions for this particular userId</dd>
<dd><code>appName</code> - If non-<code>null</code>, restricts the results to sessions for this particular app-name. Do realize
            that it is the Client that specifies this value, there is no restriction and you cannot trust that
            this String falls within your expected values.</dd>
<dd><code>appVersionAtOrAbove</code> - If non-<code>null</code>, restricts the results to sessions having app-version at or above the
            specified value, using ordinary alphanum comparison. Do realize that it is the Client that specifies
            this value, there is no restriction and you cannot trust that this String falls within your expected
            values.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the list of all MatsSocketSessions currently registered with this MatsSocketServer instance matching the
         constraints if set - as read from the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>data store</code></a>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></code> - if the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>ClusterStoreAndForward</code></a> makes any problems when reading sessions from it.</dd>
</dl>
</li>
</ul>
<a name="getMatsSocketSessionsCount-boolean-java.lang.String-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMatsSocketSessionsCount</h4>
<pre>int&nbsp;getMatsSocketSessionsCount(boolean&nbsp;onlyActive,
                               java.lang.String&nbsp;userId,
                               java.lang.String&nbsp;appName,
                               java.lang.String&nbsp;appVersionAtOrAbove)
                        throws <a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></pre>
<div class="block">Like <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getMatsSocketSessions-boolean-java.lang.String-java.lang.String-java.lang.String-"><code>getMatsSocketSessions(boolean, String, String, String)</code></a>, only returning the count - this might be
 interesting if there are very many sessions, and you do not need the full DTOs of every Session, just the count
 for a metric to graph or similar.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of all MatsSocketSessions currently registered with this MatsSocketServer instance matching the
         constraints if set - as read from the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>data store</code></a>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../../io/mats3/matssocket/MatsSocketServer.DataStoreException.html" title="class in io.mats3.matssocket">MatsSocketServer.DataStoreException</a></code> - if the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>ClusterStoreAndForward</code></a> makes any problems when reading sessions from it.</dd>
</dl>
</li>
</ul>
<a name="getActiveMatsSocketSessions--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getActiveMatsSocketSessions</h4>
<pre>java.util.SortedMap&lt;java.lang.String,<a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSessionDto.html" title="class in io.mats3.matssocket">MatsSocketServer.ActiveMatsSocketSessionDto</a>&gt;&nbsp;getActiveMatsSocketSessions()</pre>
<div class="block">This returns static, frozen-in-time, "copied-out" DTO-variants of the <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getLiveMatsSocketSessions--"><code>LiveMatsSocketSessions</code></a>. Please observe the difference between <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ActiveMatsSocketSession</code></a> and
 <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.LiveMatsSocketSession</code></a>. If you have a massive amount of sessions, and only need the sessions for
 appName="MegaCorpWebBank", then you should consider not employing this method, but instead do a variant of what
 this method does, where you restrict the "copy out" to the relevant sessions:

 <pre>
 SortedMap&lt;String, ActiveMatsSocketSessionDto&gt; ret = new TreeMap&lt;&gt;();
 for (LiveMatsSocketSession liveSession : getLiveMatsSocketSessions().values()) {
     // === HERE YOU MAY ADD CRITERIA on the LiveMatsSocketSession, doing 'continue' if not matched ===
     // :: "Copy it out"
     ActiveMatsSocketSessionDto activeSession = liveSession.toActiveMatsSocketSession();
     // ?: Check that the LiveSession is still SESSION_ESTABLISHED
     if (liveSession.getState() != MatsSocketSessionState.SESSION_ESTABLISHED) {
         // -&gt; No, it changed during copying, so then we drop this.
         continue;
     }
     // Add to result Map
     ret.put(activeSession.getMatsSocketSessionId(), activeSession);
 }
 return ret;
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a current snapshot of <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>ActiveMatsSocketSession</code></a>s - these are the
         <b>active</b> MatsSocketSessions <b>which are active right now on <i>this node</i></b> of the set of
         nodes (i.e. cluster) that represents this <i>instance</i> of MatsSocketServer. Notice that all returned
         instances had state=<a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.MatsSocketSessionState.html#SESSION_ESTABLISHED"><code>SESSION_ESTABLISHED</code></a> at the time of
         capture.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ActiveMatsSocketSession</code></a>, 
<a href="../../../io/mats3/matssocket/MatsSocketServer.html#getLiveMatsSocketSessions--"><code>getLiveMatsSocketSessions()</code></a></dd>
</dl>
</li>
</ul>
<a name="getLiveMatsSocketSessions--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLiveMatsSocketSessions</h4>
<pre>java.util.Map&lt;java.lang.String,<a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket">MatsSocketServer.LiveMatsSocketSession</a>&gt;&nbsp;getLiveMatsSocketSessions()</pre>
<div class="block">Imagine that the MatsSocketServer uses a <code>ConcurrentMap</code> to keep its set of local, live, currently
 connected MatsSocketSessions. This method then returns an unmodifiable view of this Map. This means that you can
 get session instances, and iterate over it, but the contents will change over time as Clients come and go, i.e.
 connects and disconnects. It also means that you can get this Map instance once, and keep a local copy of it, and
 it will always be current. It again also means that if you want a "static list" of these sessions, either use
 <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getActiveMatsSocketSessions--"><code>getActiveMatsSocketSessions()</code></a> which gives you a snapshot, "frozen-in-time" view of the active sessions,
 where both the sessions, and the contents of the sessions, are static. Or you may copy the values of this
 returned Map into another container - but in the latter case, the <i>contents</i> of those LiveMatsSocketSession
 instances are still live. Please observe the difference between <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ActiveMatsSocketSession</code></a> and
 <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.LiveMatsSocketSession</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an unmodifiable concurrent live view of <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>LiveMatsSocketSession</code></a>s - these are
         the <b>live</b> MatsSocketSessions <b>which are active right now on <i>this node</i></b> of the set of
         nodes (i.e. cluster) that represents this <i>instance</i> of MatsSocketServer.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/mats3/matssocket/MatsSocketServer.html#getActiveMatsSocketSessions--"><code>getActiveMatsSocketSessions()</code></a></dd>
</dl>
</li>
</ul>
<a name="addSessionEstablishedEventListener-io.mats3.matssocket.MatsSocketServer.SessionEstablishedEventListener-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addSessionEstablishedEventListener</h4>
<pre>void&nbsp;addSessionEstablishedEventListener(<a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.SessionEstablishedEventListener</a>&nbsp;listener)</pre>
<div class="block"><a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.html" title="interface in io.mats3.matssocket"><code>SessionEstablishedEvent</code></a> listeners will be invoked when an
 <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>LiveMatsSocketSession</code></a> is established <b>on this node</b> of the
 <a href="../../../io/mats3/matssocket/MatsSocketServer.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer</code></a> instance cluster, i.e. the authentication/authorization is accepted, HELLO message from
 Client is processed and MatsSocketSessionId is established. Note that this means that in a fairly load balanced
 3-node MatsSocketServer cluster, you should get approximately 1/3 of the SessionEstablishedEvents on "this" node,
 while 2/3 of them will come on the "other" two nodes.
 <p/>
 Note: A specific MatsSocketSession with a specific MatsSocketSessionId can be established multiple times, due to
 <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.SessionEstablishedEventType.html#RECONNECT"><code>RECONNECT</code></a>.
 <p/>
 <b>NOTE: You are advised against keeping hold of the <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>LiveMatsSocketSession</code></a> instance
 that is provided in the <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.html" title="interface in io.mats3.matssocket"><code>SessionEstablishedEvent</code></a>.</b> You can instead get a view
 of the currently live sessions for this node by means of <a href="../../../io/mats3/matssocket/MatsSocketServer.html#getLiveMatsSocketSessions--"><code>getLiveMatsSocketSessions()</code></a>. If you still
 decide to hold on to these active sessions instances, you must be <b><i>very</i></b> certain to remove it from
 your held instances when getting <b>any</b> <a href="../../../io/mats3/matssocket/MatsSocketServer.html#addSessionRemovedEventListener-io.mats3.matssocket.MatsSocketServer.SessionRemovedEventListener-"><code>SessionRemovedEvent</code></a>, meaning that you must remove it for any of the <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#DEREGISTER"><code>DEREGISTER</code></a>, <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#CLOSE"><code>CLOSE</code></a> and <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#TIMEOUT"><code>TIMEOUT</code></a>
 event types: The live session instance is <i>dead</i> for all of these events. If you were to remove it only on
 CLOSE or TIMEOUT, believing that a DEREGISTER is a "softer" removal, you have basically misunderstood! You could
 then get a DEREGISTER (which actually is the server informing you that it has ditched this LiveMatsSocketSession
 and the session is now solely represented in the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>data store</code></a>, while you still
 stubbornly hold on to it!), and then not get a corresponding TIMEOUT for the same MatsSocketSessionId until many
 hours, or days, later. If you fail to remove it at all, you will eventually get an OutOfMemory situation. The
 reason here is that a MatsSocketSession instance is never "reanimated", even if the MatsSocketSession is just
 DEREGISTERed: A new LiveMatsSocketSession instance is <i>always</i> created upon a <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.html" title="interface in io.mats3.matssocket"><code>SessionEstablishedEvent</code></a>, both for <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.SessionEstablishedEventType.html#NEW"><code>NEW</code></a> <i>and</i>
 <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.SessionEstablishedEventType.html#RECONNECT"><code>RECONNECT</code></a></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - the <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEventListener.html" title="interface in io.mats3.matssocket"><code>SessionEstablishedListener</code></a> that shall get invoked when
            MatsSocketSessions are established.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/mats3/matssocket/MatsSocketServer.html#addSessionRemovedEventListener-io.mats3.matssocket.MatsSocketServer.SessionRemovedEventListener-"><code>addSessionRemovedEventListener(SessionRemovedEventListener)</code></a>, 
<a href="../../../io/mats3/matssocket/MatsSocketServer.html#getLiveMatsSocketSessions--"><code>getLiveMatsSocketSessions()</code></a>, 
<a href="../../../io/mats3/matssocket/MatsSocketServer.html#getActiveMatsSocketSessions--"><code>getActiveMatsSocketSessions()</code></a></dd>
</dl>
</li>
</ul>
<a name="addSessionRemovedEventListener-io.mats3.matssocket.MatsSocketServer.SessionRemovedEventListener-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addSessionRemovedEventListener</h4>
<pre>void&nbsp;addSessionRemovedEventListener(<a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.SessionRemovedEventListener</a>&nbsp;listener)</pre>
<div class="block"><a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.SessionRemovedEvent</code></a> listeners will be invoked when an <a href="../../../io/mats3/matssocket/MatsSocketServer.LiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.LiveMatsSocketSession</code></a> is removed from this
 node of the <a href="../../../io/mats3/matssocket/MatsSocketServer.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer</code></a> instance cluster - this is both when a MatsSocketSession is
 <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#DEREGISTER"><code>DEREGISTERed</code></a>, in which case the Client can still
 <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.SessionEstablishedEventType.html#RECONNECT"><code>RECONNECT</code></a> to the same MatsSocketSessionId, and when a
 MatsSocketSession is <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#CLOSE"><code>CLOSEd</code></a> or <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#TIMEOUT"><code>TIMEOUTed</code></a>. In the latter cases, any information of the MatsSocketSession and its MatsSocketSessionId are deleted
 from the MatsSocketServer, and the session cannot be reconnected again.
 <p/>
 Note: A specific MatsSocketSession can <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#DEREGISTER"><code>DEREGISTER</code></a> multiple times, due
 to it can <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEvent.SessionEstablishedEventType.html#RECONNECT"><code>RECONNECT</code></a> again after each DEREGISTER. However, once it
 has <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#CLOSE"><code>CLOSE</code></a> or <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#TIMEOUT"><code>TIMEOUT</code></a>, the session
 cannot RECONNECT ever again, and hence those events are terminal wrt. to that specific MatsSocketSessionId.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - the <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionEstablishedEventListener.html" title="interface in io.mats3.matssocket"><code>SessionEstablishedListener</code></a> that shall get invoked when
            MatsSocketSessions are removed (either deregistered, closed or timed out).</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/mats3/matssocket/MatsSocketServer.html#addSessionEstablishedEventListener-io.mats3.matssocket.MatsSocketServer.SessionEstablishedEventListener-"><code>addSessionEstablishedEventListener(SessionEstablishedEventListener)</code></a></dd>
</dl>
</li>
</ul>
<a name="addMessageEventListener-io.mats3.matssocket.MatsSocketServer.MessageEventListener-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addMessageEventListener</h4>
<pre>void&nbsp;addMessageEventListener(<a href="../../../io/mats3/matssocket/MatsSocketServer.MessageEventListener.html" title="interface in io.mats3.matssocket">MatsSocketServer.MessageEventListener</a>&nbsp;listener)</pre>
<div class="block"><a href="../../../io/mats3/matssocket/MatsSocketServer.MessageEventListener.html" title="interface in io.mats3.matssocket"><code>MessageEventListener</code></a>s will be invoked for every processed incoming and outgoing
 message for any session. It will be invoked <i>after</i> the message is processed OK on incoming, and
 <i>after</i> the message is sent for outgoing. Note that the <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEnvelopeWithMetaDto.html" title="class in io.mats3.matssocket"><code>MatsSocketServer.MatsSocketEnvelopeWithMetaDto</code></a> contains more
 information than is sent over the wire, this is the "WithMeta" aspect which holds processing metadata - the
 wire-part is what is contained in <a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEnvelopeDto.html" title="class in io.mats3.matssocket"><code>MatsSocketServer.MatsSocketEnvelopeDto</code></a>.
 <p/>
 <b>Note wrt. modifications on the <code>MatsSocketEnvelopeWithMetaDto</code>! All fields are public and
 non-final, so you can modify it before e.g. sending it over Mats (e.g. nulling out the 'msg' field). However,
 read the JavaDoc comment on the class: There is only one single instance for all listeners and
 <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html#getLastEnvelopes--"><code>MatsSocketServer.ActiveMatsSocketSession.getLastEnvelopes()</code></a> "last envelopes"}, so clone it before modifying!</b>
 <p/>
 Note: The last messages per <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ActiveMatsSocketSession</code></a> is available via
 <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html#getLastEnvelopes--"><code>MatsSocketServer.ActiveMatsSocketSession.getLastEnvelopes()</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - the <a href="../../../io/mats3/matssocket/MatsSocketServer.MessageEventListener.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.MessageEventListener</code></a> that will be invoked for every processed incoming and outgoing
            envelope for any session.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html#getLastEnvelopes--"><code>MatsSocketServer.ActiveMatsSocketSession.getLastEnvelopes()</code></a>, 
<a href="../../../io/mats3/matssocket/MatsSocketServer.MatsSocketEnvelopeWithMetaDto.html" title="class in io.mats3.matssocket"><code>MatsSocketServer.MatsSocketEnvelopeWithMetaDto</code></a></dd>
</dl>
</li>
</ul>
<a name="closeSession-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>closeSession</h4>
<pre>void&nbsp;closeSession(java.lang.String&nbsp;sessionId,
                  java.lang.String&nbsp;reason)</pre>
<div class="block">Closes the specified MatsSocketSession - can be used to forcibly close an active MatsSocketSession (i.e. "kick it
 off"), and can also used to perform out-of-band closing of Session if the WebSocket is down (this is used in the
 MatsSocket.js Client, where an "onunload"-listener is attached, so that if the user navigates away, every effort
 is done to get the MatsSocketSession closed).
 <p/>
 Note: An invocation of any <a href="../../../io/mats3/matssocket/MatsSocketServer.html#addSessionRemovedEventListener-io.mats3.matssocket.MatsSocketServer.SessionRemovedEventListener-"><code>SessionRemoved
 listeners</code></a> with type <a href="../../../io/mats3/matssocket/MatsSocketServer.SessionRemovedEvent.SessionRemovedEventType.html#CLOSE"><code>CLOSE</code></a> will be issued.
 <p/>
 Note: This can be done on any node of the MatsSocketServer-instance cluster, as the instruction will be forwarded
 to the active node if the MatsSocketSession is not active on this node. If it is not active on any node, it will
 nevertheless be closed in the <a href="../../../io/mats3/matssocket/ClusterStoreAndForward.html" title="interface in io.mats3.matssocket"><code>data store</code></a> (i.e. the session cannot reconnect
 again).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sessionId</code> - the id of the Session to close.</dd>
<dd><code>reason</code> - a short descriptive String of why it was closed.</dd>
</dl>
</li>
</ul>
<a name="stop-int-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>stop</h4>
<pre>void&nbsp;stop(int&nbsp;gracefulShutdownMillis)</pre>
<div class="block">Closes all <a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><code>MatsSocketServer.ActiveMatsSocketSession</code></a> on this node, closing the WebSocket with
 <code>CloseReason.CloseCodes.SERVICE_RESTART</code> (assuming that a MatsSocket service will never truly go down, thus effectively
 asking the client to reconnect, hopefully to another instance). Should be invoked at application shutdown.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../io/mats3/matssocket/ClusterStoreAndForward.WrongUserException.html" title="class in io.mats3.matssocket"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../io/mats3/matssocket/MatsSocketServer.ActiveMatsSocketSession.html" title="interface in io.mats3.matssocket"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/mats3/matssocket/MatsSocketServer.html" target="_top">Frames</a></li>
<li><a href="MatsSocketServer.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
